Mp3ler
==========

**Mp3ler** — это сервис поиска и скачивания музыки, использующий социальную сеть вконтакте в качестве источника.

Принцип работы
--------------
Сайт использует в качестве источника контента социальную сеть вконтакте.

При любом поисковом запросе на сайт, идет обращение сервера вконакте через официальное API. В качестве аккаунтов API используются тестовые пустые приложения. тем не менее, вконтакте выдает каптчу, которую нужно решать — для этого используется antigate.com. После того, как результаты найдены, они сохраняются во внутренний кеш (таблица mysql). Дабы минимизировать количество обращений к вконтакте, этот кеш никогда не чистится.

После того, как результаты найдены, пользователь может выбрать трек для скачивания. Трек для скачивания — это ссылка на поиск, которая содержит точное название трека.

При скачивании трека соблюдается следующий алгоритм:

1. Для начала проверяется, если этот трек уже был скачан, если файл существует на диске и если этот файл не битый, то мы отдаем этот файл напрямую как отдаем любой обычный файл (используя на продакшене nginx `X-Accel-Redirect`)
2. В противном случае, мы пытаемся его скачать из вконтакте. У вконтакте есть ссылка на прямое скачивание, которая работает только с одного ip ограниченное количество времени.
3. Если ссылка не работает — значит она просрочилась. Поэтому делаем новый запрос к вконтакте (принудительно сбрасывая кеш)
4. Если два раза подряд не удалось скачать трек, значит по другому мы его скачать уже никак не сможем (либо терк исчез из вконтакте, либо еще что-то случилось). В этом случае мы выдаем 404 ошибку.

Из-за того, что ссылки на прямое скачивание из вконтакте жестко привязаны к ip, при скачивании трека мы проверям, с нужного ли сервере идет запрос, и если нет — то принудительно редиректим пользвателя на нужный сервер (`s1.mp3ler.biz/download/...`). Если трек уже скачан, то он просто переводится на тот же сервер, на который нас в текущий момент направил load-balancer.

Ссылки для скачивания живут примерно 6 часов, и формируются при поиске точного трека. Формируется уникальная хеш, зависящий от названия трека и текущего таймстампа. Этот хеш используется в ссылке для скачивания и записывается в redis с json-данными о треке (обычно это необходимая информация для скачивания — id сервера с которого нужно скачивать, название трека, id вконтакте и т.д.). При скачивании из redis эта информация достается.

Требования
----------
*  PHP 5.4 + cURL + phpredis + memcache
*  MySQL (основное хранилище данных)
*  Redis (дополнительное хранилище для хранения данных кликов партнерки)
*  Memcached (весь кеш)
*  Yii framework 1.1.14

Установка
---------
1. Стандартный git clone репозитория с программным кодом + установка yii в `../framework`
2. Настройка конфигурационных файлов `protected/config`. В существующие файлы (main.php, urls.php, ...) лезть и менять не надо. Нужно самим создать следующие файлы (примеры лежат в `*.example.php`в этой же директории):
    * `cache.php` — кеширование
    * `database.php` — база данных
    * `captcha.php` — доступы к сервису распознавания каптчи antigate.com
    * `environment.php` — настройки окружения
    * `params.php` — кастомные параметры (пути, домены)
    * `server.php` — настройка работы сайта при использовании нескольких серверов
    * `session.php` — настройки хранения сессий
3. Выполнить миграции yii (если БД еще не установлена)
3. Установить crontab от того же пользователя, что и запускается само приложение, если это первый сервер
4. Установить секретную cookie `debug_mode_28f` в 1 (либо перейти в `/console/debug`) чтобы включить WebLog профайлер для себя на сайте, если это первоначальная установка

Добавление нового сервера в конфигурацию
----------------------------------------
Для добавления нового сервера в конфигурацию, нужно:
1. Выдать отдельный домен (поддомен) для этого сервера, к примеру, s5.localhost
2. Настроить приложение на этом поддомене выполняя инструкции по установке
3. Добавить в server.php на всех серверах блок с описанием сервера
4. Добавить в load-balancer этот сервер

Фоновые задания
---------------
Для корректной работы приложение требует запуска некоторого количества фоновых задач
*  `./yiic vk resetAlive` — запускает обнуление статусов ошибок аккаунтов. Если не запускать, то в конце концов аккаунты отключаются по мелких ошибкам и заново их никто не включает. Запускать рекомендуется раз в 30 минут (подойдет на одном сервере).
*  `./yiicd antigate solve` — запускает решалку каптчей. Выполнен как демон, т.е. должен быть запущен в фоне всегда. Можно добавить в crontab `@reboot`. Внимание! Должен быть запущен только на одном сервере, во избежании того, что одна и та же каптча будет отправлена на решение несколько раз.

Пример crontab'а:

    # Каждый час обнуляем проблемные аккаунты
    @hourly cd /var/www/mp3ler/public_html/mp3ler.biz/protected && ./yiic vk resetAlive > /var/www/mp3ler/public_html/mp3ler.biz/protected/runtime/resetAlive.log 2>&1

    # После ребута запускаем демон, следяющий за статусом каптчей
    @reboot cd /var/www/mp3ler/public_html/mp3ler.biz/protected && ./yiicd antigate solve > /var/www/mp3ler/public_html/mp3ler.biz/protected/runtime/solve.log 2>&1


За чем нужно следить
--------------------
1. Чтобы не кончалось место в хранилище — в этом случае будет избыточное количество обращений к вконтакте
2. Чтобы не кончались деньги на antigate.com — в этом случае перестает работать поиск
3. Чтобы фоновые задания работали (можно упустить их запуск при ребуте) — иначе перестанет работать поиск

Таблицы MySQL
-------------
База данных MySQL используется как основное хранилище для данных.
*  `query` — поисковые запросы
*  `query_queue` — очередь поисковых запросов
*  `track` — mp3-треки, сохраненные на диске
*  `user` — пользователи
*  `vk_account` — список аккаунтов vk
*  `vk_cache` — кеш ответа api вконтакте

Бекапить необходимо все данные, кроме `vk_cache` — эта информация восстанавливается и не влияет на работоспособность (однако, если есть возможность — лучше бекапить).

Ключи Redis
-----------
* **Общая информация о кликах**
    * `t:t` (transition : time) — сортированный список (sorted set) **засчитанных кликов**, где score — таймстамп клика, member — идентификатор клика
    * `nct:t` (not counted transition : time) — сортированный список (sorted set) **не засчитанных кликов**, где score — таймстамп клика, member — идентификатор клика
* **Информация о кликах для партнера**
    * `p:t:ip:{id}` (partner transition ip)  — множество (set) уникальных ip засчитанных кликов для партнера `{id}` за все время
    * `p:t:t:{id}` (partner : transition : time) — сортированный список (sorted set) **засчитанных кликов** партнера `{id}`, где score — таймстамп клика, member — идентификатор клика
    * `p:nct:t:{id}` (partner : not counted transition : time) — сортированный список (sorted set) **не засчитанных кликов** партнера `{id}`, где score — таймстамп клика, member — идентификатор клика
* **Клики**
    * `t:ar` (transition autoincrement) — числовое поле для автоинкремента id кликов
    * `t:i` (transition info) — хеш (hash) с данными о кликах (всех) партнера, где field — идентификатор клика, member — json-обьект с данными. TODO: [сделать так][1]
* **Сессии**
    * `s:{id}` (session) — строка с данными сессии с идентификатором {id}, хранение происхоит через стандартные средства php (session.save_handler) и redis.so. Ключ живет определенное время (настраивается в конфиге session.php)
* **Скачивания**
    * `d:{id}` (download) — строка с данными (json) о временной ссылке скачивания трека, где {id} — идентификатор ссылки. Ключ живет определенное время (настраивается в params.php)

Бекапить необходимо все данные

  [1]: http://instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value-pairs
